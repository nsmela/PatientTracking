@page "/templates"

<MudContainer Class="pa-1">
    <!-- Templates -->
    @foreach (var template in Templates) {
        <MudPaper Width="560px" Class="ma-2" Outlined="true" Style="@($"background:{Colors.BlueGrey.Darken4};")">
            <MudToolBar DisableGutters="true">
                <MudText Typo="Typo.h4" Class="pl-1">@template.Label</MudText>
                <MudSpacer />
                <MudMenu Icon="@Icons.Material.Rounded.MoreHoriz" AnchorOrigin="Origin.BottomRight"
                     TransformOrigin="Origin.TopRight" ListClass="pa-2 d-flex flex-column" PopoverClass="mud-elevation-25">
                    <MudButton Size="Size.Small" Color="Color.Success" StartIcon="@Icons.Material.Filled.PersonAddAlt1">Create Patient</MudButton>
                    <MudButton Size="Size.Small" Color="Color.Default" StartIcon="@Icons.Material.Rounded.Edit" OnClick="@(()=> SetActiveTemplate(template))">Edit Template</MudButton>
                    <MudButton Size="Size.Small" Color="Color.Error" StartIcon="@Icons.Material.Filled.RemoveCircle" OnClick="@(()=> RemoveTemplate(template))">Remove Template</MudButton>
                </MudMenu>
            </MudToolBar>
            <!-- Groups -->
            @foreach (var group in template.Groups) {
                <MudPaper Class="ma-2 pb-2" Style="@($"background:{Colors.BlueGrey.Darken1};")">
                    @if (IsActiveTemplate(template) && OpenedGroupForEditing is not null && OpenedGroupForEditing.Value.Key.Equals(template) && OpenedGroupForEditing.Value.Value.Equals(group)) {
                        <MudToolBar DisableGutters="true" Style="@($"background:{Colors.BlueGrey.Darken2};")">
                        <MudTextField @bind-Value="group.Label" Placeholder="@group.Label" TextChanged="@(()=> EditGroupSubmit())" 
                                    Class="pl-2" Variant="Variant.Filled" Immediate="false"/>
                            <MudSpacer />
                            <MudIconButton Icon="@Icons.Material.Rounded.Edit" Size="Size.Small" OnClick="(() => EditGroupSubmit())" />
                        </MudToolBar>
                    }else{
                        <MudToolBar DisableGutters="true" Style="@($"background:{Colors.BlueGrey.Darken2};")">
                            <MudText Typo="Typo.h5" Class="pl-2">@group.Label</MudText>
                            <MudSpacer />
                            <MudIconButton Icon="@Icons.Material.Filled.KeyboardArrowUp" Size="Size.Small" OnClick="(() => IncrementGroup(template, group))" />
                            <MudIconButton Icon="@Icons.Material.Sharp.KeyboardArrowDown" Size="Size.Small" OnClick="(() => DecrementGroup(template, group))" />
                            <MudMenu Icon="@Icons.Material.Rounded.MoreHoriz" AnchorOrigin="Origin.BottomRight" TransformOrigin="Origin.TopRight"
                             ListClass="pa-2 d-flex flex-column" PopoverClass="mud-elevation-25">
                                <MudButton Size="Size.Small" Color="Color.Default" StartIcon="@Icons.Material.Rounded.Edit" OnClick="(() => OpenGroupNameEdit(template, group))">Rename Section</MudButton>
                                <MudButton Size="Size.Small" Color="Color.Error" StartIcon="@Icons.Material.Filled.RemoveCircle" OnClick="(() => RemoveGroup(template, group))">Remove Group</MudButton>
                            </MudMenu>
                        </MudToolBar>
                    }
                    <!-- Tasks -->
                    @foreach (var task in group.Tasks) {
                        <TemplateTaskItem Group=@group Task=@task GroupChanged=@OnGroupUpdated Editing=@true />
                    }
                    @if(AddTaskId[0] == template.Id && AddTaskId[1] == group.Id){
                        <MudPaper Outlined="true" Class="ma-1 pa-1" >
                            <MudTextField @bind-Value="newTaskLabel" Placeholder="New Task" DisableUnderLine="true" />
                            <MudButton FullWidth="true" OnClick="(() => AddTaskToGroup(group))"> Add Task </MudButton>
                        </MudPaper>
                    }else {
                        <MudButton FullWidth="true" OnClick="(() => ToggleAddTask(template.Id, group.Id))"> New Task </MudButton>
                    }

                </MudPaper>
            }

            @if (IsActiveTemplate(template))
            {
                <MudStack Rows="true" Spacing="1">
                    <MudButton> New Group </MudButton>
                    <MudButton OnClick="@(()=> ResetTemplate(template))"> Reset </MudButton>
                <MudButton  OnClick="@(()=> SaveTemplate(template))"> Save </MudButton>
               </MudStack>
            }
        </MudPaper>
    }
</MudContainer>
    


@code {
    [Inject] PatientService patientService { get; set; }
    [Inject] TemplateService templateService { get; set; }
    private TaskGroupsTemplate[] _patientTemplates;
    private TasksTemplate[] _taskTemplates;

    private Template[] Templates {get; set;}
    private TaskGroup[] GroupTemplates {get; set;}


    int activeTemplateId = -1;

    protected override async Task OnInitializedAsync(){
        GetTemplates();
    }

    private async Task GetTemplates(){
        var result = await templateService.GetAllTemplates();
        var templates = new List<Template>();

        result.ForEach(r => {
            var template = new Template {
                    Label = r.Label,
                    Id = r.Id,
                    Groups = new List<TaskGroup>()
                };

            var groups = new List<TaskGroup>();
            r.Groups.ForEach(g => {
                var group = new TaskGroup {
                        Label = g.Label,
                        Tasks = new List<TaskItem>()
                    };
                g.Tasks.ForEach(t => group.Tasks.Add(new TaskItem { Label = t.Label }));
                groups.Add(group);
            });
            template.Groups = groups;
            templates.Add(template);
        });

        Templates = templates.ToArray();
    }

    #region Task Functions
    //variables needed for these functions
    int[] AddTaskId { get; set; } = new int[] { -1, -1 };
    int[] EditTaskId { get; set; } = new int[] { -1, -1 , -1};

    string newTaskLabel { get; set; } = string.Empty;
    bool isInEditMode = false;

    //functions
    private void IncrementTask(TaskGroup group, TaskItem task) {
        int index = group.Tasks.IndexOf(task);
        if (index <= 0) return;

        group.Tasks.Remove(task);
        group.Tasks.Insert(index - 1, task);
    }

    private void DecrementTask(TaskGroup group, TaskItem task) {
        int index = group.Tasks.IndexOf(task);
        if (index >= group.Tasks.Count() - 1) return; //already at bottom

        group.Tasks.Remove(task);
        group.Tasks.Insert(index + 1, task);
    }

    private void RemoveTask(TaskGroup group, TaskItem task){
        group.Tasks.Remove(task);
    }

    private void OpenEditTask(int templateId, int groupId, int taskId){
        EditTaskId[0] = templateId;
        EditTaskId[1] = groupId;
        EditTaskId[2] = taskId;
    }

    private void EditTaskSubmit(){
        if(!isInEditMode){isInEditMode = true; return; }

        EditTaskId = new int[] { -1, -1, -1 };
        isInEditMode = false;
    }

    private void ToggleAddTask(int templateId, int groupId){
        if(AddTaskId[0] == templateId && AddTaskId[1] == groupId){
            AddTaskId = new int[] { -1, -1 };
            return;
        }

        AddTaskId = new int[] { templateId, groupId };
    }

    private void AddTaskToGroup(TaskGroup group){
        if (AddTaskId[0] < 0 || AddTaskId[1] < 0) return;

        if (newTaskLabel is not null && newTaskLabel != string.Empty) {
            var task = new TaskItem { Label = newTaskLabel };
            group.Tasks.Add(task);
        }

        AddTaskId = new int[] { -1, -1 };
        newTaskLabel = string.Empty;
    }

    private async Task OnGroupUpdated(TaskGroup group){
        foreach(var template in Templates){
            foreach(var tGroup in template.Groups){
                if(tGroup == group){
                    int index = Array.IndexOf(Templates, template);
                    int groupIndex = template.Groups.IndexOf(tGroup);
                    Templates[index].Groups[groupIndex] = group;
                    return;
                }
            }
        }
    }

    #endregion

    #region Group Functions
    //variables
    KeyValuePair<Template, TaskGroup>? OpenedGroupForEditing = null;

    //functions
    private void IncrementGroup(Template template, TaskGroup group){
        int index = template.Groups.IndexOf(group);
        if(index <= 0) return;

        template.Groups.Remove(group);
        template.Groups.Insert(index - 1, group);
    }

    private void DecrementGroup(Template template, TaskGroup group){
        int index = template.Groups.IndexOf(group);
        if(index >= template.Groups.Count() - 1) return;

        template.Groups.Remove(group);
        template.Groups.Insert(index + 1, group);
    }

    private void RemoveGroup(Template template, TaskGroup group){
        template.Groups.Remove(group);
    }

    private void OpenGroupNameEdit(Template template, TaskGroup group){
        OpenedGroupForEditing = new KeyValuePair<Template, TaskGroup>(template, group);
    }

    bool IsGroupNameEditMode = false;
    private void EditGroupSubmit(){
        // this is triggered the first time rendered, so we use up the first triggered instance to do nothing
        if(!IsGroupNameEditMode){
            IsGroupNameEditMode = true;
            return;
        }

        IsGroupNameEditMode = false;
        OpenedGroupForEditing = null;
    }
    #endregion

    #region Template Functions
    Template? activeTemplate = null;

    private void SetActiveTemplate(Template template){
        if(activeTemplate is not null) return; //need to save/clear previously opened template first

        activeTemplate = template;
    }

    private async Task SaveTemplate(Template template){
        if (!IsActiveTemplate(template)) return;
        if(template == null) return;

        //send values to database to save
        await templateService.UpdateTemplate(template);

        //remove form from editing
        activeTemplate = null;
    }

    private async Task ResetTemplate(Template template){
        if (!IsActiveTemplate(template)) return;

        //grab original from service
        GetTemplates();
    }

    private void RemoveTemplate(Template template){
        int index = Array.IndexOf(Templates, template);
        if (index < 0) return; //doesn't exist

        var templates = new List<Template>();
        for(int i = 0; i < Templates.Length; i++) if (Templates[i] != template) templates.Add(Templates[i]);

        Templates = templates.ToArray();
    }
    #endregion

    //check if template is the actively edited template
    private bool IsActiveTemplate(Template template){
        if (activeTemplate is null) return false;
        if(template is null) return false;
        if (activeTemplate != template) return false;

        return true;
    }

    //submit edited task

}
