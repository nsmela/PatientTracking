@page "/templates"

<MudContainer Class="pa-1">
    <!-- Templates -->
    @foreach (var template in Templates) {
        <MudPaper Width="560px" Class="ma-2" Outlined="true" Style="@($"background:{Colors.BlueGrey.Darken4};")">
            <MudToolBar DisableGutters="true">
                <MudText Typo="Typo.h4" Class="pl-1">@template.Label</MudText>
                <MudSpacer />
                <MudMenu Icon="@Icons.Material.Rounded.MoreHoriz" AnchorOrigin="Origin.BottomRight"
                     TransformOrigin="Origin.TopRight" ListClass="pa-2 d-flex flex-column" PopoverClass="mud-elevation-25">
                    <MudButton Size="Size.Small" Color="Color.Success" StartIcon="@Icons.Material.Filled.PersonAddAlt1">Create Patient</MudButton>
                    <MudButton Size="Size.Small" Color="Color.Default" StartIcon="@Icons.Material.Rounded.Edit" OnClick="@(()=> SetActiveTemplate(template))">Edit Template</MudButton>
                    <MudButton Size="Size.Small" Color="Color.Error" StartIcon="@Icons.Material.Filled.RemoveCircle" OnClick="@(()=> RemoveTemplate(template))">Remove Template</MudButton>
                </MudMenu>
            </MudToolBar>
            <!-- Groups -->
            @foreach (var group in template.Groups) {
                <TemplateGroupItem Editing=@true Group=@group PatientTemplate=@template TemplateChanged=@OnTemplateUpdated />
            }

            @if (IsActiveTemplate(template))
            {
                <MudStack Rows="true" Spacing="1">
                    <MudButton> New Group </MudButton>
                    <MudButton OnClick="@(()=> ResetTemplate(template))"> Reset </MudButton>
                <MudButton  OnClick="@(()=> SaveTemplate(template))"> Save </MudButton>
               </MudStack>
            }
        </MudPaper>
    }
</MudContainer>
    


@code {
    [Inject] PatientService patientService { get; set; }
    [Inject] TemplateService templateService { get; set; }
    private TaskGroupsTemplate[] _patientTemplates;
    private TasksTemplate[] _taskTemplates;

    private TemplateItem[] Templates {get; set;}
    private TaskGroup[] GroupTemplates {get; set;}


    int activeTemplateId = -1;

    protected override async Task OnInitializedAsync(){
        GetTemplates();
    }

    private async Task GetTemplates(){
        var result = await templateService.GetAllTemplates();
        var templates = new List<TemplateItem>();

        result.ForEach(r => {
            var template = new TemplateItem {
                    Label = r.Label,
                    Id = r.Id,
                    Groups = new List<TaskGroup>()
                };

            var groups = new List<TaskGroup>();
            r.Groups.ForEach(g => {
                var group = new TaskGroup {
                        Label = g.Label,
                        Tasks = new List<TaskItem>()
                    };
                g.Tasks.ForEach(t => group.Tasks.Add(new TaskItem { Label = t.Label }));
                groups.Add(group);
            });
            template.Groups = groups;
            templates.Add(template);
        });

        Templates = templates.ToArray();
    }

    #region Task Functions
    int[] AddTaskId = new int[] { -1, -1 };
    string newTaskLabel = string.Empty;

    private void ToggleAddTask(int templateId, int groupId){
        if(AddTaskId[0] == templateId && AddTaskId[1] == groupId){
            AddTaskId = new int[] { -1, -1 };
            return;
        }

        AddTaskId = new int[] { templateId, groupId };
    }

    private void AddTaskToGroup(TaskGroup group){
        if (AddTaskId[0] < 0 || AddTaskId[1] < 0) return;

        if (newTaskLabel is not null && newTaskLabel != string.Empty) {
            var task = new TaskItem { Label = newTaskLabel };
            group.Tasks.Add(task);
        }

        AddTaskId = new int[] { -1, -1 };
        newTaskLabel = string.Empty;
    }

    private async Task OnGroupUpdated(TaskGroup group){
        foreach(var template in Templates){
            foreach(var tGroup in template.Groups){
                if(tGroup == group){
                    int index = Array.IndexOf(Templates, template);
                    int groupIndex = template.Groups.IndexOf(tGroup);
                    Templates[index].Groups[groupIndex] = group;
                    return;
                }
            }
        }
    }

    #endregion

    #region Group Functions
    //variables
    KeyValuePair<TemplateItem, TaskGroup>? OpenedGroupForEditing = null;

    //functions
    private void IncrementGroup(TemplateItem template, TaskGroup group){
        int index = template.Groups.IndexOf(group);
        if(index <= 0) return;

        template.Groups.Remove(group);
        template.Groups.Insert(index - 1, group);
    }

    private void DecrementGroup(TemplateItem template, TaskGroup group){
        int index = template.Groups.IndexOf(group);
        if(index >= template.Groups.Count() - 1) return;

        template.Groups.Remove(group);
        template.Groups.Insert(index + 1, group);
    }

    private void RemoveGroup(TemplateItem template, TaskGroup group){
        template.Groups.Remove(group);
    }

    private void OpenGroupNameEdit(TemplateItem template, TaskGroup group){
        OpenedGroupForEditing = new KeyValuePair<TemplateItem, TaskGroup>(template, group);
    }

    bool IsGroupNameEditMode = false;
    private void EditGroupSubmit(){
        // this is triggered the first time rendered, so we use up the first triggered instance to do nothing
        if(!IsGroupNameEditMode){
            IsGroupNameEditMode = true;
            return;
        }

        IsGroupNameEditMode = false;
        OpenedGroupForEditing = null;
    }
    #endregion

    #region Template Functions
    TemplateItem? activeTemplate = null;

    private void SetActiveTemplate(TemplateItem template){
        if(activeTemplate is not null) return; //need to save/clear previously opened template first

        activeTemplate = template;
    }

    private async Task SaveTemplate(TemplateItem template){
        if (!IsActiveTemplate(template)) return;
        if(template == null) return;

        //send values to database to save
        await templateService.UpdateTemplate(template);

        //remove form from editing
        activeTemplate = null;
    }

    private async Task ResetTemplate(TemplateItem template){
        if (!IsActiveTemplate(template)) return;

        //grab original from service
        GetTemplates();
    }

    private void RemoveTemplate(TemplateItem template){
        int index = Array.IndexOf(Templates, template);
        if (index < 0) return; //doesn't exist

        var templates = new List<TemplateItem>();
        for(int i = 0; i < Templates.Length; i++) if (Templates[i] != template) templates.Add(Templates[i]);

        Templates = templates.ToArray();
    }

        private async Task OnTemplateUpdated(TemplateItem template){
        foreach(var t in Templates){
            int index = Array.IndexOf(Templates, template);
            Templates[index] = template;
            return;
                
            
        }
    }
    #endregion

    //check if template is the actively edited template
    private bool IsActiveTemplate(TemplateItem template){
        if (activeTemplate is null) return false;
        if(template is null) return false;
        if (activeTemplate != template) return false;

        return true;
    }

    //submit edited task

}
